# Using semantic feature

You can create useful RDF output by annotating our model.
For this you use the `semantics` field in EMX2.

## Formatting

There are 2 types of data allowed in this field:
* an IRI (such as `http://purl.org/dc/terms/title`)
* a prefixed name (such as `dcterms:title`), assuming that prefix [is defined](#defined-namespaces)
 

When processing a semantic field, a check is done to see if it can be interpreted as a prefixed name (based on the defined namespaces for that scheme).
If not, then it is assumed to be an IRI.

Multiple values can be defined by separating these by a comma (such as `dcterms:title,http://purl.org/dc/terms/description`).

## Defined namespaces

By default, the following prefixed names are available:
<!-- see: https://github.com/molgenis/molgenis-emx2/blob/master/backend/molgenis-emx2-rdf/src/main/java/org/molgenis/emx2/rdf/DefaultNamespace.java -->
<!-- regex-from: ^.*\("([\w\-]+)", "([\d\w:\/\.\-\#]+)".*$ -->
<!-- regex-to: | $1 | $2 | -->

| prefix        | IRI                                            |
|---------------|------------------------------------------------|
| afr           | http://purl.allotrope.org/ontologies/result#   |
| afrl          | http://purl.allotrope.org/ontologies/role#     |
| dc            | http://purl.org/dc/elements/1.1/               |
| dcat          | http://www.w3.org/ns/dcat#                     |
| dcatap        | http://data.europa.eu/r5r/                     |
| dcterms       | http://purl.org/dc/terms/                      |
| edam          | http://edamontology.org/                       |
| efo           | http://www.ebi.ac.uk/efo/                      |
| ejp           | https://w3id.org/ejp-rd/vocabulary#            |
| ensembl       | http://ensembl.org/glossary/                   |
| fdp-o         | https://w3id.org/fdp/fdp-o#                    |
| fg            | https://w3id.org/fair-genomes/resource/        |
| foaf          | http://xmlns.com/foaf/0.1/                     |
| healthdcatap  | http://healthdataportal.eu/ns/health#          |
| hl7           | http://purl.bioontology.org/ontology/HL7/      |
| ldp           | http://www.w3.org/ns/ldp#                      |
| lnc           | http://purl.bioontology.org/ontology/LNC/      |
| mesh          | http://purl.bioontology.org/ontology/MESH/     |
| obo           | http://purl.obolibrary.org/obo/                |
| oboInOwl      | http://www.geneontology.org/formats/oboInOwl#  |
| odrl          | http://www.w3.org/ns/odrl/2/                   |
| ordo          | http://www.orpha.net/ORDO/                     |
| org           | http://www.w3.org/ns/org#                      |
| owl           | http://www.w3.org/2002/07/owl#                 |
| prov          | http://www.w3.org/ns/prov#                     |
| qb            | http://purl.org/linked-data/cube#              |
| rdf           | http://www.w3.org/1999/02/22-rdf-syntax-ns#    |
| rdfs          | http://www.w3.org/2000/01/rdf-schema#          |
| schema        | http://schema.org/                             |
| sio           | http://semanticscience.org/resource/           |
| skos          | http://www.w3.org/2004/02/skos/core#           |
| snomedct      | http://purl.bioontology.org/ontology/SNOMEDCT/ |
| vcard         | http://www.w3.org/2006/vcard/ns#               |
| xsd           | http://www.w3.org/2001/XMLSchema#              |

!> The IRI for healthDCAT-AP is a placeholder as it [currently does not have one defined](https://healthdcat-ap.github.io/#namespaces).

!> The list above can be overridden using a [schema-specific advanced setting](./dev_rdf.md#custom-semantic-prefixes).

## Ontologies

If semantics are defined for a column that refers to an ontology table, a check is made to see if an `ontologyTermURI` is defined for that target reference.
If this is the case, a triple is generated that uses the `ontologyTermURI` directly as object instead of an IRI that refers to the primary key of the ontology table.
This way, ontologies can be used to define a list of allowed IRIs for a specific column in a data table.

## Examples

### Semantics in general 

Using the pet store schema with demo data, the User table looks like this:

![image](../img/semantics.png)

In this example, `username` is the <span style="color:#FF8C82">primary key</span> of the table.
Therefore, it defines the subject of a triple.
If there is a composite key, the combination of these columns define the subject.

The <span style="color:#94E3FE">semantics value</span> for each column define the predicates.
No matter if the semantics field is empty or not, EMX2 always generates it's own EMX2 format.

Finally, the actual <span style="color:#B1DD8C">values in a cell</span> define the objects in a triple.
If the `ColumnType` is an `ARRAY`, multiple objects can be present.

To visualize this using the actual RDF Turtle output generated by this table, specific fields have been colored below similar to the image/text above:

<pre style="white-space: pre-wrap;">
<span style="color:#FF8C82">&lt;http://localhost:8080/pet%20store/api/rdf/User?username=bofke&gt;</span> a PetStore:User, qb:Observation,
<span style="color:#94E3FE">foaf:Person</span>;
qb:dataSet PetStore:User;
<span style="color:#FF8C82">rdfs:label "bofke"</span>;
<span style="color:#94E3FE">foaf:accountName</span> <span style="color:#B1DD8C">"bofke"</span>;
<span style="color:#94E3FE">&lt;http://localhost:8080/pet%20store/api/rdf/User/column/username&gt;</span> <span style="color:#B1DD8C">"bofke"</span>;
<span style="color:#94E3FE">foaf:img</span> <span style="color:#B1DD8C">&lt;http://localhost:8080/pet%20store/api/file/User/picture/8b6677b7700c44118c953eb79c76d76a&gt;</span>;
<span style="color:#94E3FE">&lt;http://localhost:8080/pet%20store/api/rdf/User/column/picture&gt;</span> <span style="color:#B1DD8C">&lt;http://localhost:8080/pet%20store/api/file/User/picture/8b6677b7700c44118c953eb79c76d76a&gt;</span>;
<span style="color:#94E3FE">&lt;http://example.com/petstore#hasPets&gt;</span> <span style="color:#B1DD8C">&lt;http://localhost:8080/pet%20store/api/rdf/Pet?name=the+very+hungry+caterpillar&gt;,
&lt;http://localhost:8080/pet%20store/api/rdf/Pet?name=spike&gt;, &lt;http://localhost:8080/pet%20store/api/rdf/Pet?name=fire+ant&gt;,
&lt;http://localhost:8080/pet%20store/api/rdf/Pet?name=pooky&gt;</span>;
<span style="color:#94E3FE">&lt;http://localhost:8080/pet%20store/api/rdf/User/column/pets&gt;</span> <span style="color:#B1DD8C">&lt;http://localhost:8080/pet%20store/api/rdf/Pet?name=the+very+hungry+caterpillar&gt;,
&lt;http://localhost:8080/pet%20store/api/rdf/Pet?name=spike&gt;, &lt;http://localhost:8080/pet%20store/api/rdf/Pet?name=fire+ant&gt;,
&lt;http://localhost:8080/pet%20store/api/rdf/Pet?name=pooky&gt;</span>;
fdp-o:metadataIssued "2025-02-20T13:46:29"^^xsd:dateTime;
dcterms:issued "2025-02-20T13:46:29"^^xsd:dateTime;
&lt;http://localhost:8080/pet%20store/api/rdf/User/column/mg_insertedOn&gt; "2025-02-20T13:46:29"^^xsd:dateTime;
fdp-o:metadataModified "2025-02-20T13:46:29"^^xsd:dateTime;
&lt;http://localhost:8080/pet%20store/api/rdf/User/column/mg_updatedOn&gt; "2025-02-20T13:46:29"^^xsd:dateTime .
</pre>

### References to an ontology table

When a reference is done to an ontology table, it slightly deviates from a regular reference.
For the example below, keep in mind that the referenced ontology table contains the following rows regarding color:

| name   | parent | ontologyTermURI                |
|--------|--------|--------------------------------|
| colors |        |                                |
| red    | colors | https://dbpedia.org/page/Red   |
| green  | colors | https://dbpedia.org/page/Green |
| blue   | colors |                                |
| purple | colors |                                |

The <span style="color:#FF8C82">objects of the non-semantic predicate</span> are IRIs that refer to the primary key of the ontology table (like a regular reference).  

However, the <span style="color:#94E3FE">objects of the semantic predicate</span> contain the `ontologyTermURI` belonging to that ontology reference, if one was found (as can be seen for "red" and "green"). If no `ontologyTermURI` was defined, it uses the primary key of the ontology table instead (see "purple").


<pre style="white-space: pre-wrap;">
&lt;http://localhost:8080/pet%20store/api/rdf/Pet?name=fire+ant&gt; a PetStore:Pet, qb:Observation;
dcat:endpointURL &lt;http://localhost:8080/pet%20store/api/rdf/&gt;;
fdp-o:metadataIdentifier &lt;http://localhost:8080/pet%20store/api/rdf/Pet?name=fire+ant&gt;;
qb:dataSet PetStore:Pet;
rdfs:label "fire ant";
&lt;http://localhost:8080/pet%20store/api/rdf/Pet/column/name&gt; "fire ant";
&lt;http://localhost:8080/pet%20store/api/rdf/Pet/column/category&gt; &lt;http://localhost:8080/pet%20store/api/rdf/Category?name=ant&gt;;
&lt;http://localhost:8080/pet%20store/api/rdf/Pet/column/status&gt; "available";
&lt;http://localhost:8080/pet%20store/api/rdf/Pet/column/tags&gt; <span style="color:#FF8C82">&lt;http://localhost:8080/pet%20store/api/rdf/Tag?name=purple&gt;,
&lt;http://localhost:8080/pet%20store/api/rdf/Tag?name=green&gt;, &lt;http://localhost:8080/pet%20store/api/rdf/Tag?name=red&gt;</span>;
&lt;http://example.com/petstore#hasTags&gt; <span style="color:#94E3FE">&lt;http://localhost:8080/pet%20store/api/rdf/Tag?name=purple&gt;,
&lt;https://dbpedia.org/page/Red&gt;, &lt;https://dbpedia.org/page/Green&gt;</span>;
&lt;http://localhost:8080/pet%20store/api/rdf/Pet/column/weight&gt; 1.0E-2;
&lt;http://localhost:8080/pet%20store/api/rdf/Pet/column/mg_insertedOn&gt; "2025-03-18T12:04:55"^^xsd:dateTime;
&lt;http://localhost:8080/pet%20store/api/rdf/Pet/column/mg_updatedOn&gt; "2025-03-18T12:04:55"^^xsd:dateTime .
</pre>

## JSON-LD for harvesting and import

The JSON-LD API allows semantic data exchange with external systems. This is useful for:
- Publishing data for harvesters (DCAT-AP, FAIR Data Points)
- Importing data from Linked Data sources
- Integrating with semantic web tooling

### Schema with semantic annotations

Define a DCAT-compatible catalog schema:

```csv
tableName,tableSemantics,columnName,columnType,key,refTable,semantics
Catalog,dcat:Catalog,id,STRING,1,,dcterms:identifier
Catalog,,title,STRING,,,dcterms:title
Catalog,,description,TEXT,,,dcterms:description
Catalog,,publisher,REF,,Organization,dcterms:publisher
Catalog,,datasets,REF_ARRAY,,Dataset,dcat:dataset
Dataset,dcat:Dataset,id,STRING,1,,dcterms:identifier
Dataset,,title,STRING,,,dcterms:title
Dataset,,description,TEXT,,,dcterms:description
Dataset,,issued,DATE,,,dcterms:issued
Dataset,,keywords,STRING_ARRAY,,,dcat:keyword
Organization,foaf:Organization,id,STRING,1,,dcterms:identifier
Organization,,name,STRING,,,foaf:name
Organization,,homepage,HYPERLINK,,,foaf:homepage
```

### JSON-LD export with @context

Request data via the JSON-LD API:

```bash
curl https://example.org/my-catalog/api/jsonld/Catalog
```

Response includes semantic `@context`:

```json
{
  "@context": {
    "@base": "https://example.org/my-catalog/",
    "my": "https://example.org/my-catalog#",
    "dcat": "http://www.w3.org/ns/dcat#",
    "dcterms": "http://purl.org/dc/terms/",
    "foaf": "http://xmlns.com/foaf/0.1/",
    "mg_id": "@id",
    "data": "@graph",
    "@embed": "@always",
    "Catalog": {"@id": "my:Catalog", "@type": "dcat:Catalog"},
    "Dataset": {"@id": "my:Dataset", "@type": "dcat:Dataset"},
    "Organization": {"@id": "my:Organization", "@type": "foaf:Organization"},
    "id": "dcterms:identifier",
    "title": "dcterms:title",
    "description": "dcterms:description",
    "publisher": {"@id": "dcterms:publisher", "@type": "@id"},
    "datasets": {"@id": "dcat:dataset", "@type": "@id"},
    "issued": {"@id": "dcterms:issued", "@type": "xsd:date"},
    "keywords": "dcat:keyword",
    "name": "foaf:name",
    "homepage": {"@id": "foaf:homepage", "@type": "@id"}
  },
  "data": {
    "Catalog": [
      {
        "mg_id": "Catalog/id=cat-001",
        "id": "cat-001",
        "title": "Research Data Catalog",
        "description": "Catalog of research datasets",
        "publisher": {"mg_id": "Organization/id=org-001", "name": "Example University"},
        "datasets": [
          {"mg_id": "Dataset/id=ds-001", "title": "Climate Data 2024"}
        ]
      }
    ]
  }
}
```

### Subsetting with GraphQL-LD

Use GraphQL-LD for selective harvesting:

```bash
curl -X POST -H "Content-Type: application/json" \
  -d '{"query": "{ Catalog { id title datasets { id title issued } } }"}' \
  https://example.org/my-catalog/api/graphql-ld
```

Response (only requested fields, with @context):

```json
{
  "@context": { ... },
  "data": {
    "Catalog": [
      {
        "mg_id": "Catalog/id=cat-001",
        "id": "cat-001",
        "title": "Research Data Catalog",
        "datasets": [
          {
            "mg_id": "Dataset/id=ds-001",
            "id": "ds-001",
            "title": "Climate Data 2024",
            "issued": "2024-01-15"
          }
        ]
      }
    ]
  }
}
```

### Converting to Turtle

The JSON-LD output can be converted to Turtle using any JSON-LD processor:

```bash
# Using jsonld-cli
curl https://example.org/my-catalog/api/jsonld/Catalog | jsonld format -q

# Or request Turtle directly
curl https://example.org/my-catalog/api/ttl/Catalog
```

Result:

```turtle
@prefix dcat: <http://www.w3.org/ns/dcat#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

<https://example.org/my-catalog/Catalog/id=cat-001> a dcat:Catalog ;
    dcterms:identifier "cat-001" ;
    dcterms:title "Research Data Catalog" ;
    dcterms:description "Catalog of research datasets" ;
    dcterms:publisher <https://example.org/my-catalog/Organization/id=org-001> ;
    dcat:dataset <https://example.org/my-catalog/Dataset/id=ds-001> .
```

### Importing JSON-LD data

POST JSON-LD data to import. The `@context` and `@` keywords are automatically stripped:

```bash
curl -X POST -H "Content-Type: application/ld+json" \
  -H "x-molgenis-token: $TOKEN" \
  -d '{
    "@context": "https://schema.org/",
    "@type": "dcat:Dataset",
    "id": "ds-002",
    "title": "Biodiversity Survey",
    "description": "Species count data",
    "issued": "2024-03-20",
    "keywords": ["biodiversity", "ecology", "species"]
  }' \
  https://example.org/my-catalog/api/jsonld/Dataset
```

You can also import plain JSON (without `@` fields) to the same endpoint:

```bash
curl -X POST -H "Content-Type: application/json" \
  -H "x-molgenis-token: $TOKEN" \
  -d '{
    "id": "ds-003",
    "title": "Water Quality Measurements",
    "issued": "2024-06-01"
  }' \
  https://example.org/my-catalog/api/jsonld/Dataset
```

### Roundtrip example

Export, modify externally, and re-import:

```bash
# 1. Export catalog as JSON-LD
curl https://example.org/my-catalog/api/jsonld/_all > catalog.jsonld

# 2. Edit catalog.jsonld externally (add datasets, fix metadata, etc.)

# 3. Re-import (upserts based on primary keys)
curl -X PUT -H "x-molgenis-token: $TOKEN" \
  -H "Content-Type: application/ld+json" \
  -d @catalog.jsonld \
  https://example.org/my-catalog/api/jsonld/_all
```

### Content negotiation

Use the `/api/data/` endpoint for format-agnostic access:

```bash
# Harvester requests JSON-LD
curl -H "Accept: application/ld+json" \
  https://example.org/my-catalog/api/data/Catalog

# Browser requests JSON
curl -H "Accept: application/json" \
  https://example.org/my-catalog/api/data/Catalog

# RDF tool requests Turtle
curl -H "Accept: text/turtle" \
  https://example.org/my-catalog/api/data/Catalog
```

All return the same data in different serializations.

### Turtle output with filtering

Filter data using query parameters:

```bash
# Get only available datasets as Turtle
curl "https://example.org/my-catalog/api/ttl/Dataset?filter={\"status\":{\"equals\":\"available\"}}"
```

Result (filtered):

```turtle
@prefix dcat: <http://www.w3.org/ns/dcat#> .
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<https://example.org/my-catalog/Dataset/id=ds-001> a dcat:Dataset ;
    dcterms:identifier "ds-001" ;
    dcterms:title "Climate Data 2024" ;
    dcterms:issued "2024-01-15"^^xsd:date ;
    dcat:keyword "climate", "temperature", "weather" .
```

### Turtle with GraphQL subsetting

Use GraphQL-LD to select specific fields, then convert to Turtle:

```bash
# Request only id, title, and keywords via GraphQL-LD
curl -X POST -H "Content-Type: application/json" \
  -d '{"query": "{ Dataset { id title keywords } }"}' \
  https://example.org/my-catalog/api/graphql-ld | jsonld format -q
```

Or use the TTL endpoint with a custom GraphQL query:

```bash
# Subset via query parameter
curl "https://example.org/my-catalog/api/ttl/Dataset?query={Dataset{id,title,keywords}}"
```

Result (only selected fields):

```turtle
@prefix dcat: <http://www.w3.org/ns/dcat#> .
@prefix dcterms: <http://purl.org/dc/terms/> .

<https://example.org/my-catalog/Dataset/id=ds-001> a dcat:Dataset ;
    dcterms:identifier "ds-001" ;
    dcterms:title "Climate Data 2024" ;
    dcat:keyword "climate", "temperature", "weather" .

<https://example.org/my-catalog/Dataset/id=ds-002> a dcat:Dataset ;
    dcterms:identifier "ds-002" ;
    dcterms:title "Biodiversity Survey" ;
    dcat:keyword "biodiversity", "ecology", "species" .
```

### Combined filter and subset

Combine filtering with field selection:

```bash
# Get datasets from 2024 with only title and issued date
curl "https://example.org/my-catalog/api/ttl/Dataset?filter={\"issued\":{\"like\":\"2024%\"}}&query={Dataset{title,issued}}"
```

Result:

```turtle
@prefix dcterms: <http://purl.org/dc/terms/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<https://example.org/my-catalog/Dataset/id=ds-001>
    dcterms:title "Climate Data 2024" ;
    dcterms:issued "2024-01-15"^^xsd:date .

<https://example.org/my-catalog/Dataset/id=ds-002>
    dcterms:title "Biodiversity Survey" ;
    dcterms:issued "2024-03-20"^^xsd:date .
```

### Pagination for large exports

Use limit and offset for paginated Turtle export:

```bash
# Get first 100 datasets
curl "https://example.org/my-catalog/api/ttl/Dataset?limit=100&offset=0"

# Get next 100
curl "https://example.org/my-catalog/api/ttl/Dataset?limit=100&offset=100"
```