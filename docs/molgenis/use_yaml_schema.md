# ðŸ§¬ MOLGENIS YAML modeling language â€” User Documentation

STILL DECIDING ON TABLE VS ENTITY, COLUMN VS FIELD


**MOLGENIS YAML modeling language 1.0** is a modular YAML-based metadata schema language used to define data models for the MOLGENIS
platform. With EMX2 generation3.0,
we introduce enhanced features for UI generation, modular reuse, semantic annotation, versioning, and rich web/data interfaces.

---

## ðŸš€ Key Features

- One YAML file defines all: **Web forms**, **CSV/Excel format **, **REST**, **GraphQL**, **RDF**, **LDP**
- Native support for **modular composition**, **ontologies**, **polymorphism**, and **computed logic**
- Support for **authoring**, **licensing**, **data typing**, **validation**, and **dynamic UI behavior**
- Rich semantics on class and instance level

---

## ðŸ”– Simple example

A simple example below:

```yaml
schema:
  name: pet store
  description: my pet store
  entities:
  - entity: Pets
    description: the table with the pets
    columns:
    - name: name
      label: Unique name
      key: 1
      # key1 is implicitly also required: true
    - name: status
      # enum implies type=enum
      enum: [available,unavailable]
      required: true
    - name: species
      # ontology file, implies type=ontology
      ontology: ../species.csv
    - name: weight
      type: int
  - name: Orders
    columns:
    - name: order id
      description: auto generated identifier
      default: snowflake()
      readonly: true
    - name: pet
      # multiselect is a lookup type, translates to foreign key
      multiselect: Pets
      required: true
    - name: date delivered
      type: date
      # n.b. field id will be autogenerated as camelCase from name
      validIf: dateDelivered < today()
    - name: customer
      select: Customer
      # todo? can filter the 'select' lookup
      # lookupFilter: {status: {equals:'active'}}
  - name: Customer
    columns:
    - name: customer id
      key: 1

```

---

## Schema modeling

Below a synthetic schema example showing all schema properties:

```yaml
schema:
  name: some name
  description: this is an example schema
  prefixes:
  # see section on Semantics modeling
  settings:
  # see section on Settings modeling
  tables:
  # see section on Table modeling

```

Definition of the properties

| Schema property | Usage                                                                                                                                                       |
|-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------|
| tables          | listing of the tables in this schema                                                                                                                        |
| name            | name of the schema. Is only used when including this schema into a schema registry, because in practice each schema instance will have their own local name |
| description     | (optional) human readable description                                                                                                                       |
| prefixes        | (optional) used for semantics. See section on Semantics.                                                                                                    |
| settings        | (optional) used for settings. See section on Settings                                                                                                       |

---

## Table modeling

Below a synthetic schema example showing all table properties:

```yaml
table:
  name: mytab
  label: My table
  description: A table description
  settings:
  # see settings modeling
  semantics:
  # see Semantic modeling
  variants:
  # see Variant modeling
  columns:
  # either 'headings:' or 'columns:'
  # see Section modeling and Field modeling
```

A table can have the following properties:

| Property   | Usage                                                                                                                                                                                                                                                                      |
|------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| name       | Table name must be unique within a schema. Name must start with a letter, followed by zero or more letters, numbers, spaces or underscores. A space immediately before or after an underscore is not allowed. The character limit is 31 (so it fits in Excel sheet names). |
| label      | (optional) user friendly label. Generally we recommend against labels because it leads to confusion                                                                                                                                                                        |
| conformsTo | (optional) list of table shapes that this table should be compatible with                                                                                                                                                                                                  |
| semantics  | (optional) semantic definition for this table. See section on Semantics                                                                                                                                                                                                    |
| variants   | (optional) definition of subtypes for this table. See section on Table polymorphism                                                                                                                                                                                        |
| settings   | (optional) definition of settings for this table. See section on Settings                                                                                                                                                                                                  |
| version    | (optional) indicate version number. Overrides schema version number if exists                                                                                                                                                                                              |

### Table variants

There are some use cases where tables ideally can be used in different subtypes. In object oriented modeling this is known as inheritance.
This is useful to allow for different views, to allow foreign key checks to only go to rows of a specific type.

variants can be defined as follows:

```yaml
table: Catalogued resources
variants:
# variant names must be unique within the schema
- name: Datasets
  # the active variant for a row can be depending on a column value
  # otherwise mg_variant will be used, set by the user. 
  # a row can be of multiple types
  when: type === 'Dataset'
- name: Catalogues
  when: type === 'Catalogue'
- name: Dataset serices
  # (multiple) inheritance is possible, except for the primary key
  extends: [Dataset]
columns:
- name: id
  key: 1
  # primary key cannot have a variant
- name: type
  # in this case we use an ontology to choose between variants
  ontology: Catalogue resource types
- name: part of catalogue
  select: Catalogues
  # this relation is only shown in Datasets
  variants: [Datasets]
- name: datasets
  subtable:
  variants: [Catalogue]


```

---

## Field modeling

An artificial example showing many field options, except semantics and predicates (see section on semantics/precidates):

```yaml
table: My table
variants:
- name: subtype
columns:
- name: f1
  label: field one
  description: some description
  # indicate that field is unique
  key: 1
  type: select
  # if type is a lookup then lookupTable is required
  lookupTable: some table
  lookupLabel: ${name}
  # filtering using some graphql filter expression
  lookupFilter: {name: {equals: ['a','b']}}
  visibleIf: otherfield > 0
  readonly: true
- name: f2
  label: other field
  type: int
  validIf: f2 > 0
  default: 2
  examples: [1,2,3]
  variant: [subtype]
- name: f3
  computed: f2*2
  #  not shown in user interface
  hidden: true
```

Field can have the following properties

| property    | Usage                                                                                                                                                                                                                                               |
|-------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| name        | (required) name unique within the containing table                                                                                                                                                                                                  |
| label       | (optional) human readable label. Unique within the containing table. Cannot conflict with other names.                                                                                                                                              |
| key         | (optional) to indicate what key a column is part of. Should be numbers. key: 1 is a special case denoting primary key of the table, which is then used for lookups                                                                                  |
| type        | (optional) value type, default 'string'. We support primive types: string, int, bigint, decimal, long, date, datetime, bool, text, hyperlink, period, <br/><br/>uuid, file, email, json, autoid, and lookup types: select, radio, ontology, .... |
| description | (optional) human readable description                                                                                                                                                                                                               |
| visibleIf   | (optional) javascript expression if the field is visible                                                                                                                                                                                            |
| validIf     | (optional) javascript expression if the field value is valid                                                                                                                                                                                        |
| readonly    | (optional) indicate that a field cannot be edited after insertion                                                                                                                                                                                   |
| hidden      | (optional) indicate that a field is hidden in the user interface                                                                                                                                                                                    |
| computed    | (optional) is a javascript expression to calculate value of this field. Field will not be editable                                                                                                                                                  |
| default     | (optional) provide a default value                                                                                                                                                                                                                  |
| variant     | (optional) in what variants of the table this field should be visible. See section on Table polymorphism                                                                                                                                            |
| semantics   | (optional) allows definition of semantics of this field. See section on Semantics & Predicates                                                                                                                                                      |
| predicates  | (optional) allows generation of rdf instances from this column. See section on Semantics & Predicates                                                                                                                                               |
| migrations  | (optional) allows definition of data migrations between versions                                                                                                                                                                                    |
| version     | (optional) allows version numbering of the field. If not provided the version of table or schema is used                                                                                                                                            |
| comment     | (optional) allow to add comments not shown elsewhere                                                                                                                                                                                                |
| examples    | (optional) some example values                                                                                                                                                                                                                      |

N.B. general metadata can be applied such as 'authors'

N.B. also lookup types can be valid properties, i.e. select, select_many, radio, checkbox, enum, ontology, ontology_many.

### ðŸ”— Lookups and Relations

Relations can be defined as follows

```yaml
- name: my field
  type: <some lookup type>
  lookupTable: Table names
```

or using a shorthand notation:

```yaml
- name: my field
  <some lookup type>: Table names
```

for example:

```yaml
- name: my select
  select: Table With Select Options
```

The following lookup types are available:

| Lookup type     | Usage                                       |
|-----------------|---------------------------------------------|
| `radio`         | Select one (rendered as radio buttons)      |
| `select`        | Select one (dropdown)                       |
| `checkbox`      | Select many (rendered as checkboxes)        |
| `select_many`   | Select many (dropdown)                      |
| `ontology`      | Select one from ontology (radio + tree)     |
| `ontology_many` | Select many from ontology (checkbox + tree) |
| `subtable`      | Inline nested table                         |

The following additional options are available for lookup types:

| Lookup option | Usage                                                                                                                                                                    |
|---------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| lookupTable   | in case of a lookup type this denotes the table linked to. N.B. as a short hand for type=select and lookupTable=mytable you can also write 'select: mytable' (prefered). |      
| lookupFilter  | in case of a lookup a graphql filter object can be used. It is a javascript expression, i.e. ${otherField} will use otherField as value.                                 |
| lookupLabel   | in case of a lookup you can use a javascript string expression to calculate label. E.g. '${column1} ${column2}'                                                          

### Primary key and unique constraints

todo

### Validation expressions (validIf)

todo

### Visible expressions (visibleIf)

todo

### Default value expressions (default)

Using â€˜defaultValueâ€™ you can set a default value for a column. In forms, this value will be pre-filled. When uploading csv/excel all empty cells will receive
the defaultValue (in insert and update) Optionally you can also use javascript expressions. For example:

* duck would set a string value
* 1 would set a numeric value
* =new Date().toISOString() provides automatic date/dateTime
* ={name:"green"} could be default value for an ontology_
* =[{name:"green"}] could be default value for an ontology_array

* Known limitation: doesnâ€™t work for columns refering to a table with composite primary key (i.e. having multiple key=1 fields).

---

## Section modeling

In larger tables schema designers will want to split the form in parts, expecting in the user interface to have these as headings, and expecting that
visibleIf relations apply on the whole heading. Within API the headings are opaque and only the fields inside are available.

headings can be defined as follows:

```yaml
table:
  name: My table
  headings:
  # name is required for a heading and should be unique within a table and cannot be duplicate to any column name
  - name: name
    description: Fill in your name
    columns:
    # see column modeling
    - name: first name
      key: 1
    - name: last name
      key: 1
  - name: contact information
    # heading can be conditional
    visibleIf: firstName
    columns:
    - name: street
    - name: city
```

Each heading can have the following properties:

| Heading property | Usage                                                                                                                                                                                                                                                                      |
|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| name             | Table name must be unique within a schema. Name must start with a letter, followed by zero or more letters, numbers, spaces or underscores. A space immediately before or after an underscore is not allowed. The character limit is 31 (so it fits in Excel sheet names). |
| columns          | List of columns in this heading                                                                                                                                                                                                                                             |
| label            | (optional) user friendly label for in forms/ui. Generally we recommend against labels because it leads to confusion                                                                                                                                                        |
| description      | (optional) user friendly description for in forms/ui and documentation                                                                                                                                                                                                     |                                                                                                                                                                                                                                      
| visibleIf        | (optional) to show/hide heading using javascript expression                                                                                                                                                                                                                |
| variants         | (optional) to indicate that a heading is only for particul subtype                                                                                                                                                                                                         |

## Semantic modeling

MOLGENIS yaml has rich options for semantic annotation, and to provide specification on how rdf conversion of data in its schemas should be implemented.

A synthetic example:

```yaml
schema:
  name: My schema
  prefixes:
    # default prefixes might apply, at least 'rdf'
    foaf: http://xmlns.com/foaf/spec/#
    dct: http://purl.org/dc/terms/
  tables:
  - name: Agent
    semantics:
      rdf:type foaf:Agent
    variants:
    - name: Person
      semantics:
        rdf:type foaf:Person
        # note you don't need to use CURIE
        skos:broader http://purl.bioontology.org/ontology/SNOMEDCT/125676002
    - name: Organisation
      semantics:
        rdf:type foaf:Organization
    columns:
    - name: id
      predicates: [dct:identifier]
    - name: first name
      pkey: 2
      predicates: [foaf:firstName]
      domain: Person
    - name: last name
      pkey: 2
      predicates: [foaf:lastName]
      domain: Person


```

Properties for semantic annotation:

| Semantics property | Usage                                                                                                                                 |
|--------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| prefixes           | a map of prefix, iri which can be used for CURIE in semantics and predicates. Can be defined on schema, table, heading, column levels. |
| semantics          | any semantic statements on table or column level                                                                                       |
| predicates         | on column level, use predicates to influence how (rowid)(predicate)(column value) triples will be generated in rdf                      |

todo, generate an example of the rdf output

---

## ðŸ§¬ Modeling polymorphism such as 'inheritance'

<!--
discussion, do we want multiple inheritance between tables defined in different files?
-->

Variants allow defining different "views" or "profiles" of your table depending on a `visibleIf:` condition. Each variant:

- Always includes `key1` columns
- Can `extend:` other variants
- May define its own `semantics:` (e.g., `rdf:type`)

```yaml
table:
  name: Catalogued resource
  variants:
  - name: health data source
  - name: registry
    visibleIf: type === 'Registry'
  - name: cohort
    visibleIf: type === 'Cohort'
    # so includes all columns from registry
    extends: [health data source]
  columns:
  - name: id
    key: 1
  - name: health theme
    domain: health data source
  - name: registry type
    ontology: Registry types
    domain: registry
  - name: cohort types
    ontology: Cohort types
    domain: cohort
```

---

## Settings

Settings can be defined, using an extension of the 'column' schema that includes 'value'.
Settings can be defined on schema, table or column level.

```yaml
schema:
  name: My schema
  settings:
  - name: some boolean setting on my schema
    type: bool
    value: true
  - name: some int setting
    type: int
    validIf: someIntSetting > 0
  tables:
  - name: Person
    settings:
    - name: table type
      ontology: Table types
```

---

## Internationalization (i18n)

todo. can have i18n using 'labels' and 'descriptions'

```yaml
table:
  name: mytab
  # we can hava i18n like this, instead of 'label' and 'description'
  labels:
    en: my table
    nl: mijn tabel
  descriptions:
    en: my table descriptoin
    nl: beschrijving van de tabel in nederlands

```

## ðŸ”§ Provenance information

If necessary MOLGENIS yaml allows to add provance information.
This is available on `schema`, `table`, `heading`, and `column`.

example:

  ```yaml
schema:
  authors:
  - name: K. Joeri van der Velde
    email: k.j.van.der.velde@umcg.nl
    orcid: 0000-0002-0934-8375
  - name: Morris A. Swertz
    email: m.a.swertz@umcg.nl
    orcid: 0000-0002-0979-3401
  copyright:
    holder: University Medical Center Groningen
    years: 2019-2021
  license:
    # when licence in https://spdx.github.io/spdx-spec/v2.3/SPDX-license-list/ we don't need URL
    name: Attribution 4.0 International (CC BY 4.0)
    url: https://creativecommons.org/licenses/by/4.0/
```

| Property      | Description                                           |
|---------------|-------------------------------------------------------|
| `name`        | Required, unique identifier                           |
| `label`       | Human-readable label (supports i18n e.g. `label:nl:`) |
| `description` | Human-readable description                            |
| `semantics`   | Ontology mappings (IRI/curie â†’ label from vocab)      |
| `prefixes`    | CURIE definitions for use in semantics/imports        |
| `authors`     | List of authors with name, email, ORCID               |
| `license`     | SPDX license name and URL                             |
| `copyright`   | Owner and year                                        |
| `units`       | Path to unit ontology                                 |

---

## Fragments

todo, fragments can be any subset of molgenis yaml schema.

---

## MOLGENIS YAML file composition

Large schemas might benefit from splitting the definition between files. Also reuse of externally defined models can be done.

A MOLGENIS YAML files can contain one of the following root keys.

| Root Key    | Purpose                                       |
|-------------|-----------------------------------------------|
| `schema:`   | A full metadata schema with tables            |
| `table:`    | A single table definition                     |
| `heading:`  | A meaningful group of columns                 |
| `column:`    | A single column                               |
| `fragment:` | A reusable metadata fragment (e.g., prefixes) |

MOLGENIS yaml files can use 'import' to enable composition.

Below a few simple example 'files' and how they can be composed.

The hard bit is that we want to enable data modelers to be precise about position of each column in the forms.
This must be possible on 'heading' or on 'column' level.

```yaml
# identifiable.yaml
table:
  name: Identifiable
  columns:
  - name: id
    key: 1

---
#person.yaml
table:
  name: Person
  columns:
  # get the columns from Identifiable
  - imports: identifiable.yaml
  - name: name
    key: 2
  - name: bogus

---
# this file composes from the imports
schema:
  tables:
  - imports: [person.yaml]
    # omit the bogus column
    omits: [Person:bogus]
  - imports: [organisation.yaml]

```

---

Appendix: yaml schema of the MOLGENIS yaml schema

<!-- todo check consistency with documentation -->

```yaml
schema:
  name: molgenis
  description: schema for MOLGENIS yaml schema
  tables:
  - name: Fields interface
    # this is only a group of columns
    interface: true
    description: fragment with columns
    columns:
    - name: type
      # todo check docs on types
      enum: [string, text, int, bool, decimal, bigint, select, select_many, radio, checkbox, ontology, ontology_array, javascript]
    - name: lookupTable
      select: Tables
      visibleIf: "['select','select_many','radio','checkbox','ontology','ontology_array'].includes(type)"
    - name: required
      type: bool
    - name: readonly
      type: bool
    - name: hidden
      type: bool
    - name: visibleIf
      type: javascript
    - name: validIf
      type: javascript
  - name: Settings interface
    interface: true
    # will extend column definition but is not part of a class hierarchy
    import: Field definition
    columns:
    # settings have a value based on its type
    - name: value
      type: JSON
  - name: Schemas
    columns:
    - name: name
      key: 1
    - name: tables
      table: Tables
      reverseLookup: schema
    - name: settings
      reverseLookup: schema
      table: 
        name: Schema settings
        columns:
        - name: schema
          select: Schemas
          key: 1
        - name: name
          key: 1
        - import: Settings interface
  - name: Tables
    columns:
    - name: name
      key: 1
    - name: schema
      select: Schemas
      key: 1
    - name: columns
      table: columns
      reverseLookup: table
    - name: settings
      reverseLookup: table
      table: 
        name: Table settings
        columns:
        - name: table
          select: Tables
          key: 1
        - name: name
          key: 1
        # position matters, this means Settings interface fields are inserted here
        - import: Settings interface
  # while in yaml headings can be nested
  # in storage headings are flattened as columns, the order determines heading start
  - name: columns
    columns:
    - name: table
      key: 1
      select: Tables
      description: table this column is part of
    - name: name
      key: 1
    # position matters, this means Settings interface fields are inserted here
    - import: Fields interface

```

