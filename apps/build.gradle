/* will produce a fat jar containing all html/js dist in public_html/apps*/

plugins {
    id "java"
    id "com.github.node-gradle.node" version "7.1.0"
}

java {
    targetCompatibility = rootProject.ext.javaVersion
    sourceCompatibility = rootProject.ext.javaVersion
}

def isCI = System.getenv('CI') ? true : false


node {
    version = '22.17.0'
    pnpmVersion = "10.24.0"
    download = true
    workDir = file("build/node")
}

// list all directories in 'apps' (i.e. the individual application folders)
// and then filter from this list those folders that are side-effect of the build processs
// (if we include node_modules, .gradle, .turbo in file scans they get much slower then needed)
ext.listProjectFolders = { List<String> excludeNames = ['node_modules',".gradle","build",".turbo"] ->
    def base = project.projectDir
    def children = base.listFiles()

    if (children == null) {
        return []
    }

    return children.findAll { f ->
        f.isDirectory() && !excludeNames.contains(f.name)
    }.collect { it.name }
}
def workspaceDirs = listProjectFolders()
println "Workspace dirs = $workspaceDirs"

tasks.register('pnpm_install', PnpmTask) {
    args = ['install']
    inputs.file("package.json")
    def optionalFile = file("pnpm-lock.yaml")
    if(optionalFile.exists())     inputs.file(optionalFile)
    workspaceDirs.each { dir ->
        inputs.file("${project.projectDir}/${dir}/package.json")
    }
    outputs.file("${project.projectDir}/node_modules/.pnpm-workspace-state-v1.json")
}

//helper code for reusable input/output caching
def inputFolders = ['src','assets'
                    ,'app'
                    , 'public'
                    , 'scripts'
                    , 'server'
                    , 'types'
                    , 'tests'
                    , 'lib'
                    , 'interfaces'
                    , 'package.json'
                    , 'vite.config.js']
def registerAppInputsOutputs(Task task, List<String> workspaceDirs, List<String> inputFolders) {
    task.inputs.file("package.json")
    def optionalLock = task.project.file("pnpm-lock.yaml")
    if (optionalLock.exists()) {
        task.inputs.file(optionalLock)
    }
    workspaceDirs.each { dir ->
        task.inputs.files(
                task.project.fileTree(dir) {
                    include inputFolders
                }
        )
    }
    task.outputs.upToDateWhen { true }
}


tasks.register('pnpm_build', PnpmTask) {
    dependsOn 'pnpm_install'
    args = ['run', 'build']
    registerAppInputsOutputs(delegate, workspaceDirs, inputFolders)
}

// Util task to clean up all apps files created during build
tasks.register("cleanApps", Delete) {
    doFirst {
        // delete build directory as before
        delete(project.layout.buildDirectory)
        delete file("${project.projectDir}/node_modules")
        delete file("${project.projectDir}/.turbo")


        // delete only known workspace folders' generated things; no global fileTree over repo
        workspaceDirs.each { dirName ->
            def dir = project.file(dirName)
            if (dir.exists()) {
                delete new File(dir, ".turbo")
                delete new File(dir, "dist")
                delete new File(dir, "showCase")
                delete new File(dir, "node_modules") // optional
                delete new File(dir, "build")
            }
        }
    }

    outputs.upToDateWhen { false } // still always run when invoked
}
clean.dependsOn 'cleanApps';

// Custom task to collect all dist folders into the resources directory
// Need because gradle cannot properly detect dynamic folders created by npm workspaces
abstract class CollectDistTask extends DefaultTask {
    @TaskAction
    void collect() {
        File targetDir = project.layout.buildDirectory
                .dir("generated/resources/public_html/apps")
                .get()
                .asFile

        project.copy { spec ->
            project.file(".").eachDir { dir ->
                def showCaseDir = new File(dir, "showCase")
                def distDir = new File(dir, "dist")
                if (showCaseDir.exists()) {
                    spec.from(showCaseDir) {
                        into(dir.name)
                    }
                }
                else if (distDir.exists()) {
                    spec.from(distDir) {
                        into(dir.name)
                    }
                }

            }
            spec.into(targetDir)
        }

        println "âœ… Collected dist folders into $targetDir"
    }
}

tasks.register("collectDist", CollectDistTask) {
    dependsOn("pnpm_build")
    registerAppInputsOutputs(delegate, workspaceDirs, inputFolders)
}

tasks.register('format', PnpmTask) {
    dependsOn 'pnpm_build'
    if (!isCI) {
        args = ['run', 'format']
    } else {
        args = ['run', 'checkFormat']
    }
    registerAppInputsOutputs(delegate, workspaceDirs, inputFolders)
}

tasks.register('lint', PnpmTask) {
    dependsOn 'pnpm_build'
    args = ['run', 'lint']
    registerAppInputsOutputs(delegate, workspaceDirs, inputFolders)
}

tasks.register('testJavascript', PnpmTask) {
    dependsOn 'pnpm_build'
    args = ['run', 'test-ci']
    registerAppInputsOutputs(delegate, workspaceDirs, inputFolders)
}

test.dependsOn 'testJavascript'

sourceSets {
    main {
        resources {
            srcDir "${buildDir}/generated/main/resources"
        }
    }
}

// Link the app build to the java jar
tasks.named("processResources") {
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    dependsOn("collectDist")

    from(layout.buildDirectory.dir("generated/resources/public_html/apps")) {
        into("public_html/apps")
    }
}